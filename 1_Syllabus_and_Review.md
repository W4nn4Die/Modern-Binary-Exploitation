#### 1. Syllabus and Review


###### Linux

```Commands```

- ls
- cd
- pwd
- man
- [apropos](http://www.linfo.org/apropos.html)
    - Displays a list of all topics in the man pages that are related to the subject of a query.
- cat
- less
- mv
- cp
- rm
- nano / vim / emacs
- pipe

	```sh
	➜  ~ fortune | cowsay
	 ____________________________________
	< Body by Nautilus, Brain by Mattel. >
	 ------------------------------------
	        \   ^__^
	         \  (oo)\_______
	            (__)\       )\/\
	                ||----w |
	                ||     ||
	➜  ~
	```
	
	```sh
	➜  ~ echo "hello" | cowsay
	 _______
	< hello >
	 -------
	        \   ^__^
	         \  (oo)\_______
	            (__)\       )\/\
	                ||----w |
	                ||     ||
	➜  ~
	```
	
	```sh
	➜  ~ echo "hello" | cowsay | grep "hello"
	< hello >
	➜  ~
	```

###### C Language

![Image of Languages](images/1.jpeg)

- Compiling / Running

```sh
#include<stdio.h>

int main(int argc, char * argv[])

{

	printf("Hello World\n");
	return 0;

}
```

```sh
root@kali:~/binexp# gcc hello_world.c -o hello_world
root@kali:~/binexp# ./hello_world
Hello World
root@kali:~/binexp#
```

- Memory Manipulation

    - Example 1

	```sh
	#include<stdio.h>
	
	main()
	
	{
	
	        int i = 0;
	        char * message = "hello world";
	        char * buffer = (char *)malloc(7);
	
	        if(buffer == NULL)
	                return 1;
	
	        strncpy(buffer,message,5);
	        buffer[5] = '\n';
	        buffer[6] = '\0';
	
	        for (i = 0; i < 10; i++)
	                printf("%s", buffer);
	
	        free(buffer);
	
	}
	```
	
	```sh
	root@kali:~/binexp# gcc memory_manipulation.c -o memory_manipulation -std=gnu99
	root@kali:~/binexp# ./memory_manipulation
	hello
	hello
	hello
	hello
	hello
	hello
	hello
	hello
	hello
	hello
	root@kali:~/binexp#
	```
	
	- Example 2

	```sh
	#include<stdio.h>
	#include<unistd.h>
	
	int main(int argc, char * argv[])
	
	{
	
		char buffer[10] = {0};
		printf("Whats's your name?\n");
		read(STDIN_FILENO, buffer, 10);
		printf("Hello %s\n", buffer);
		return 0;
	
	}
	```
	
	```sh
	root@kali:~/binexp# ./name_1
	Whats's your name?
	AAA
	Hello AAA
	
	root@kali:~/binexp#
	```
	
	```sh
	root@kali:~/binexp# python -c 'print "A"*20'
	AAAAAAAAAAAAAAAAAAAA
	root@kali:~/binexp#
	```
	```sh
	root@kali:~/binexp# ./name_1
	Whats's your name?
	AAAAAAAAAAAAAAAAAAAA
	Hello AAAAAAAAAA0��
	root@kali:~/binexp#
	```
	
	```sh
	root@kali:~/binexp# python
	Python 2.7.13 (default, Jan 19 2017, 14:48:08)
	[GCC 6.3.0 20170118] on linux2
	Type "help", "copyright", "credits" or "license" for more information.
	>>> len("AAAAAAAAAA")
	10
	>>>
	```
	
	- Example 3

	```sh
	#include<stdio.h>
	#include<unistd.h>
	
	int main(int argc, char * argv[])
	
	{
	
		char buffer[10] = {0};
		printf("What's your name?\n");
		read(STDIN_FILENO, buffer, 100);
		printf("Hello %s\n", buffer);
		return 0;
	
	}
	```
	
	```sh
	root@kali:~/binexp# ./name_2
	What's your name?
	AAA
	Hello AAA
	
	root@kali:~/binexp#
	```
	
	```sh
	root@kali:~/binexp# python -c 'print "A"*20'
	AAAAAAAAAAAAAAAAAAAA
	root@kali:~/binexp#
	```
	
	```sh
	root@kali:~/binexp# ./name_2
	What's your name?
	AAAAAAAAAAAAAAAAAAAA
	Hello AAAAAAAAAAAAAAAAAAAA
	
	Segmentation fault
	root@kali:~/binexp#
	```
	
###### x86 Assembly

- Syntax

	- Intel
	
	```
	operand destination, source
	```
	
	```assembly
	mov eax, 5
	```
	
	- AT&T

	```
	operand source, destination
	```
	
	```
	mov $5, eax
	```
	
- Registers

	![Image of Registers](images/2.jpeg)

	- ```EAX EBX ECX EDX``` - General purpose registers
	- ```ESP``` - Stack pointer, “top” of the current stack frame (lower
memory)
	- ```EBP``` - Base pointer, “bottom” of the current stack frame
(higher memory)
	- ```EIP``` - Instruction pointer, pointer to the next instruction to
be executed by the CPU
	- ```EFLAGS``` - stores flag bits
		- ```ZF``` - zero flag, set when result of an operation equals zero
		- ```CF``` - carry flag, set when the result of an operation is too large/small
		- ```SF``` - sign flag, set when the result of an operation is negative

- Moving Data

	- ```mov ebx, eax```
		- Move the value in eax to ebx
	- ```mov eax, 0xDEADBEEF```
		- Move 0xDEADBEEF into eax
	- ```mov edx, DWORD PTR [0x41424344]```
		- Move the 4-byte value at address 0x41424344 into edx
	- ```mov ecx, DWORD PTR [edx]```
		- Move the 4-byte value at the address in edx, into ecx
	- ```mov eax, DWORD PTR [ecx+esi*8]```
		- Move the value at the address ecx+esi*8 into eax

- Arithmetic Operations

	- ```sub edx, 0x11```
		- edx = edx - 0x11;
	- ```add eax, ebx```
		- eax = eax + ebx;
	- ```inc edx```
		- edx++;
	- ```dec ebx```
		- ebx--;
	- ```xor eax, eax```
		- eax = eax ^ eax;
	- ```or edx, 0x1337```
		- edx = edx | 0x1337;

- Conditional Jumps
	
	- ```jz $LOC```
		- Jump to $LOC if ZF = 1
	- ```jnz $LOC```
		- Jump to $LOC if ZF = 0
	- [```jg $LOC```](https://stackoverflow.com/questions/9617877/assembly-jg-jnle-jl-jnge-after-cmp)
		- Jump to $LOC if the result of a comparison is the destination is
greater than the source

- Stack Manipulation

	- ```push ebx```
		- Subtract 4 from the stack pointer to move it towards lower memory
(zero,) and copy the value in EBX on top of the stack

		```
		sub esp, 4
		mov DWORD PTR [esp], ebx
		```
		
	- ```pop ebx```
		- Copy the value off the top of the stack and into EBX, the add 4 to the
stack pointer to move it towards higher memory (0xFFFFFFFF)

		```
		mov ebx, DWORD PTR [esp]
		add esp, 4
		```
		
- Calling / Returning

	- ```call some_function```
		-  Calls the code at some_function
		-  We need to push the return
address onto the stack, then branch to some_function

		```
		push eip
		mov eip, some_function ; not actually valid
		```
	
	- ```ret```
		- Used to return from a function call. Pops the top of the stack to eip
		
		```
		pop eip ; not actually valid
		```
		
	- nop
		- 'no operation' - does nothing

- Basic x86

![Image of x86](images/3.jpeg)

- Human Decompiler - x86 → C

![Image of x86](images/4.jpeg)