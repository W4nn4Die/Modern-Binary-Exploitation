#### crackme0x00b

###### Inspect the binary

```sh
root@kali:~/binexp/challenges# ./crackme0x00b
Enter password: teststring
Wrong!
Enter password: ^C
root@kali:~/binexp/challenges#
```

###### radare2

```sh
root@kali:~/binexp/challenges# radare2 crackme0x00b
[0x080483e0]>
```

```sh
[0x080483e0]> aaa
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze len bytes of instructions for references (aar)
[x] Analyze function calls (aac)
[ ] [*] Use -AA or aaaa to perform additional experimental analysis.
[x] Constructing a function name for fcn.* and sym.func.* functions (aan))
[0x080483e0]> afl
0x08048338    3 46           sym._init
0x08048380    1 6            sym.imp.printf
0x08048390    1 6            sym.imp.wcscmp
0x080483a0    1 6            sym.imp.puts
0x080483b0    1 6            loc.imp.__gmon_start__
0x080483c0    1 6            sym.imp.__libc_start_main
0x080483d0    1 6            sym.imp.__isoc99_scanf
0x080483e0    1 33           entry0
0x08048410    6 85           sym.__do_global_dtors_aux
0x08048470    4 35           sym.frame_dummy
0x08048494    4 101          sym.main
0x08048500    4 97           sym.__libc_csu_init
0x08048570    1 2            sym.__libc_csu_fini
0x08048572    1 4            sym.__i686.get_pc_thunk.bx
0x08048580    4 42           sym.__do_global_ctors_aux
0x080485ac    1 26           sym._fini
[0x080483e0]>
```

```sh
[0x080483e0]> s sym.main
[0x08048494]> pdf
            ;-- main:
/ (fcn) sym.main 101
|   sym.main (int arg_4h, int arg_1ch);
|           ; arg int arg_4h @ esp+0x4
|           ; arg int arg_1ch @ esp+0x1c
|           ; DATA XREF from 0x080483f7 (entry0)
|           0x08048494      55             push ebp
|           0x08048495      89e5           mov ebp, esp
|           0x08048497      83e4f0         and esp, 0xfffffff0
|           0x0804849a      83c480         add esp, -0x80
|           ; JMP XREF from 0x080484f7 (sym.main)
|       .-> 0x0804849d      b8d0850408     mov eax, str.Enter_password: ; "Enter password: " @ 0x80485d0
|       |   0x080484a2      890424         mov dword [esp], eax
|       |   0x080484a5      e8d6feffff     call sym.imp.printf        ; int printf(const char *format);
|       |   0x080484aa      b8e1850408     mov eax, 0x80485e1
|       |   0x080484af      8d54241c       lea edx, dword [esp + arg_1ch] ; 0x1c ; "4"
|       |   0x080484b3      89542404       mov dword [esp + arg_4h], edx
|       |   0x080484b7      890424         mov dword [esp], eax
|       |   0x080484ba      e811ffffff     call sym.imp.__isoc99_scanf; int scanf(const char *format);
|       |   0x080484bf      8d44241c       lea eax, dword [esp + arg_1ch] ; 0x1c ; "4"
|       |   0x080484c3      89442404       mov dword [esp + arg_4h], eax
|       |   0x080484c7      c7042440a004.  mov dword [esp], obj.pass.1964 ; [0x804a040:4]=119 LEA obj.pass.1964 ; "w" @ 0x804a040
|       |   0x080484ce      e8bdfeffff     call sym.imp.wcscmp        ; int wcscmp(const wchar_t *s1, const wchar_t *s2);
|       |   0x080484d3      85c0           test eax, eax
|      ,==< 0x080484d5      7514           jne 0x80484eb
|      ||   0x080484d7      c70424e58504.  mov dword [esp], str.Congrats_ ; [0x80485e5:4]=0x676e6f43 LEA str.Congrats_ ; "Congrats!" @ 0x80485e5
|      ||   0x080484de      e8bdfeffff     call sym.imp.puts          ; int puts(const char *s);
|      ||   0x080484e3      90             nop
|      ||   0x080484e4      b800000000     mov eax, 0
|      ||   0x080484e9      c9             leave
|      ||   0x080484ea      c3             ret
|      ||   ; JMP XREF from 0x080484d5 (sym.main)
|      `--> 0x080484eb      c70424ef8504.  mov dword [esp], str.Wrong_ ; [0x80485ef:4]=0x6e6f7257 LEA str.Wrong_ ; "Wrong!" @ 0x80485ef
|       |   0x080484f2      e8a9feffff     call sym.imp.puts          ; int puts(const char *s);
\       `=< 0x080484f7      eba4           jmp 0x804849d
[0x08048494]>
```

```sh
[0x08048b94]> pd $r @ main
            ;-- main:
/ (fcn) sym.main 101
|   sym.main (int arg_4h, int arg_1ch);
|           ; arg int arg_4h @ esp+0x4
|           ; arg int arg_1ch @ esp+0x1c
|           ; DATA XREF from 0x080483f7 (entry0)
|           0x08048494      55             push ebp
|           0x08048495      89e5           mov ebp, esp
|           0x08048497      83e4f0         and esp, 0xfffffff0
|           0x0804849a      83c480         add esp, -0x80
|           ; JMP XREF from 0x080484f7 (sym.main)
|       .-> 0x0804849d      b8d0850408     mov eax, str.Enter_password: ; "Enter password: " @ 0x80485d0
|       |   0x080484a2      890424         mov dword [esp], eax
|       |   0x080484a5      e8d6feffff     call sym.imp.printf        ; int printf(const char *format);
|       |   0x080484aa      b8e1850408     mov eax, 0x80485e1          ; "%ls"
|       |   0x080484af      8d54241c       lea edx, dword [esp + arg_1ch] ; 0x1c ; "4" ; "4"
|       |   0x080484b3      89542404       mov dword [esp + arg_4h], edx
|       |   0x080484b7      890424         mov dword [esp], eax
|       |   0x080484ba      e811ffffff     call sym.imp.__isoc99_scanf; int scanf(const char *format);
|       |   0x080484bf      8d44241c       lea eax, dword [esp + arg_1ch] ; 0x1c ; "4" ; "4"
|       |   0x080484c3      89442404       mov dword [esp + arg_4h], eax
|       |   0x080484c7      c7042440a004.  mov dword [esp], obj.pass.1964 ; [0x804a040:4]=119 LEA obj.pass.1964 ; "w" @ 0x804a040
|       |   0x080484ce      e8bdfeffff     call sym.imp.wcscmp        ; int wcscmp(const wchar_t *s1, const wchar_t *s2);
|       |   0x080484d3      85c0           test eax, eax
|      ,==< 0x080484d5      7514           jne 0x80484eb
|      ||   0x080484d7      c70424e58504.  mov dword [esp], str.Congrats_ ; [0x80485e5:4]=0x676e6f43 LEA str.Congrats_ ; "Congrats!" @ 0x80485e5
|      ||   0x080484de      e8bdfeffff     call sym.imp.puts          ; int puts(const char *s);
|      ||   0x080484e3      90             nop
|      ||   0x080484e4      b800000000     mov eax, 0
|      ||   0x080484e9      c9             leave
|      ||   0x080484ea      c3             ret
|      ||   ; JMP XREF from 0x080484d5 (sym.main)
|      `--> 0x080484eb      c70424ef8504.  mov dword [esp], str.Wrong_ ; [0x80485ef:4]=0x6e6f7257 LEA str.Wrong_ ; "Wrong!" @ 0x80485ef
|       |   0x080484f2      e8a9feffff     call sym.imp.puts          ; int puts(const char *s);
\       `=< 0x080484f7      eba4           jmp 0x804849d
            0x080484f9      90             nop
            0x080484fa      90             nop
            0x080484fb      90             nop
            0x080484fc      90             nop
            0x080484fd      90             nop
            0x080484fe      90             nop
            0x080484ff      90             nop
/ (fcn) sym.__libc_csu_init 97
|   sym.__libc_csu_init (int arg_30h, int arg_34h, int arg_38h);
|           ; var int local_4h @ esp+0x4
|           ; var int local_8h @ esp+0x8
|           ; arg int arg_30h @ esp+0x30
|           ; arg int arg_34h @ esp+0x34
|           ; arg int arg_38h @ esp+0x38
|           ; DATA XREF from 0x080483f0 (entry0)
|           0x08048500      55             push ebp
|           0x08048501      57             push edi
|           0x08048502      56             push esi
|           0x08048503      53             push ebx
|           0x08048504      e869000000     call sym.__i686.get_pc_thunk.bx
|           0x08048509      81c3eb1a0000   add ebx, 0x1aeb
|           0x0804850f      83ec1c         sub esp, 0x1c
|           0x08048512      8b6c2430       mov ebp, dword [esp + arg_30h] ; [0x30:4]=0x1b001e ; '0'
|           0x08048516      8dbb20ffffff   lea edi, dword [ebx - 0xe0]
|           0x0804851c      e817feffff     call sym._init
|           0x08048521      8d8320ffffff   lea eax, dword [ebx - 0xe0]
|           0x08048527      29c7           sub edi, eax
|           0x08048529      c1ff02         sar edi, 2
|           0x0804852c      85ff           test edi, edi
|       ,=< 0x0804852e      7429           je 0x8048559
|       |   0x08048530      31f6           xor esi, esi
|       |   0x08048532      8db600000000   lea esi, dword [esi]
|       |   ; JMP XREF from 0x08048557 (sym.__libc_csu_init)
|       |   0x08048538      8b442438       mov eax, dword [esp + arg_38h] ; [0x38:4]=52 ; '8' ; "4"
|       |   0x0804853c      892c24         mov dword [esp], ebp
|       |   0x0804853f      89442408       mov dword [esp + local_8h], eax
|       |   0x08048543      8b442434       mov eax, dword [esp + arg_34h] ; [0x34:4]=6 ; '4'
|       |   0x08048547      89442404       mov dword [esp + local_4h], eax
|       |   0x0804854b      ff94b320ffff.  call dword [ebx + esi*4 - 0xe0]
|       |   0x08048552      83c601         add esi, 1
[0x08048b94]>
```

###### Solving crackme0x00b

All Calls

```sh
0x080484a5      e8d6feffff     call sym.imp.printf        ; int printf(const char *format);
0x080484ba      e811ffffff     call sym.imp.__isoc99_scanf; int scanf(const char *format);
0x080484ce      e8bdfeffff     call sym.imp.wcscmp        ; int wcscmp(const wchar_t *s1, const wchar_t *s2);
0x080484de      e8bdfeffff     call sym.imp.puts          ; int puts(const char *s);
0x080484f2      e8a9feffff     call sym.imp.puts          ; int puts(const char *s);
```

1. Program gets the user input from ```scanf``` call at ```0x080484ba```

	```sh
	|       |   0x080484aa      b8e1850408     mov eax, 0x80485e1          ; "%ls"
	|       |   0x080484af      8d54241c       lea edx, dword [esp + arg_1ch] ; 0x1c ; "4" ; "4"
	|       |   0x080484b3      89542404       mov dword [esp + arg_4h], edx
	|       |   0x080484b7      890424         mov dword [esp], eax
	|       |   0x080484ba      e811ffffff     call sym.imp.__isoc99_scanf; int scanf(const char *format);
	```
	
	Arguments are put on the stack just prior to the call
	
	The first argument is a string constant which can be deduces using the format specifier ```%ls```
	
	[```%ls```](https://linuxprograms.wordpress.com/tag/scanf/) - To read and print a wide character string, we use the ```%ls``` format. Instead of ```%s```, we use ```%ls``` to work with the ```UTF-8``` characters. This directs ```printf``` and ```scanf``` to do special treatment (call additional functions) to the entered string
	
	Second argument is the memory location to store the ```scanf()``` result. The result of ```scanf()``` is stored in stack allocated buffer starting at ```0x1c```.

2. At ```0x080484ce``` ```wcscmp``` is called

	```sh
	|       |   0x080484bf      8d44241c       lea eax, dword [esp + arg_1ch] ; 0x1c ; "4" ; "4"
	|       |   0x080484c3      89442404       mov dword [esp + arg_4h], eax
	|       |   0x080484c7      c7042440a004.  mov dword [esp], obj.pass.1964 ; [0x804a040:4]=119 LEA obj.pass.1964 ; "w" @ 0x804a040
	|       |   0x080484ce      e8bdfeffff     call sym.imp.wcscmp        ; int wcscmp(const wchar_t *s1, const wchar_t *s2);
	```
	
	```wcscmp``` - Used to compare two wide-character strings
	
	The first argument is our user provided input stored at ```0x1c```
	
	The second argument is the string at ```obj.pass.1964``` / ```0x804a040```

3. [```Print```](https://github.com/radare/radare2/blob/master/doc/intro.md#print) the string at ```0x804a040``` / ```obj.pass.1964```

	```sh
	[0x08048494]> px 50 @ 0x804a040
	- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
	0x0804a040  7700 0000 3000 0000 7700 0000 6700 0000  w...0...w...g...
	0x0804a050  7200 0000 6500 0000 6100 0000 7400 0000  r...e...a...t...
	0x0804a060  0000 0000 4743 433a 2028 5562 756e 7475  ....GCC: (Ubuntu
	0x0804a070  2f4c                                     /L
	[0x08048494]>
	```
	
	```sh
	[0x08048494]> px 50 @ obj.pass.1964
	- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
	0x0804a040  7700 0000 3000 0000 7700 0000 6700 0000  w...0...w...g...
	0x0804a050  7200 0000 6500 0000 6100 0000 7400 0000  r...e...a...t...
	0x0804a060  0000 0000 4743 433a 2028 5562 756e 7475  ....GCC: (Ubuntu
	0x0804a070  2f4c                                     /L
	[0x08048494]>
	```

4. Finally

	```sh
	root@kali:~/binexp/challenges# ./crackme0x00b
	Enter password: w0wgreat
	Congrats!
	root@kali:~/binexp/challenges#
	```