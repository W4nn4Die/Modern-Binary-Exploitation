#### crackme0x01

###### Inspect the binary

```sh
root@kali:~/binexp/challenges# ./crackme0x01
IOLI Crackme Level 0x01
Password: jhdfkg
Invalid Password!
root@kali:~/binexp/challenges#
```

###### radare2

```sh
root@kali:~/binexp/challenges# radare2 crackme0x01
[0x08048330]>
```

```sh
[0x08048330]> aaa
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze len bytes of instructions for references (aar)
[x] Analyze function calls (aac)
[ ] [*] Use -AA or aaaa to perform additional experimental analysis.
[x] Constructing a function name for fcn.* and sym.func.* functions (aan))
[0x08048330]>
[0x08048330]> afl
0x080482d4    1 23           sym._init
0x080482fc    1 6            sym.imp.__libc_start_main
0x0804830c    1 6            sym.imp.scanf
0x0804831c    1 6            sym.imp.printf
0x08048330    1 33           entry0
0x08048354    3 33           fcn.08048354
0x08048380    6 47           sym.__do_global_dtors_aux
0x080483b0    4 50           sym.frame_dummy
0x080483e4    4 113          sym.main
0x08048460    4 99           sym.__libc_csu_init
0x080484d0    1 5            sym.__libc_csu_fini
0x080484d5    1 4            sym.__i686.get_pc_thunk.bx
0x080484e0    4 35           sym.__do_global_ctors_aux
0x08048504    1 26           sym._fini
[0x08048330]>
```

```sh
[0x08048330]> s sym.main
[0x080483e4]>
```

```sh
[0x080484e4]> pd $r @ main
            ;-- main:
/ (fcn) sym.main 113
|   sym.main ();
|           ; var int local_4h @ ebp-0x4
|           ; var int local_4h_2 @ esp+0x4
|           ; DATA XREF from 0x08048347 (entry0)
|           0x080483e4      55             push ebp
|           0x080483e5      89e5           mov ebp, esp
|           0x080483e7      83ec18         sub esp, 0x18
|           0x080483ea      83e4f0         and esp, 0xfffffff0
|           0x080483ed      b800000000     mov eax, 0
|           0x080483f2      83c00f         add eax, 0xf
|           0x080483f5      83c00f         add eax, 0xf
|           0x080483f8      c1e804         shr eax, 4
|           0x080483fb      c1e004         shl eax, 4
|           0x080483fe      29c4           sub esp, eax
|           0x08048400      c70424288504.  mov dword [esp], str.IOLI_Crackme_Level_0x01_n ; [0x8048528:4]=0x494c4f49 LEA str.IOLI_Crackme_Level_0x01_n ; "IOLI Crackme Level 0x01." @ 0x8048528
|           0x08048407      e810ffffff     call sym.imp.printf        ; int printf(const char *format);
|           0x0804840c      c70424418504.  mov dword [esp], str.Password: ; [0x8048541:4]=0x73736150 LEA str.Password: ; "Password: " @ 0x8048541
|           0x08048413      e804ffffff     call sym.imp.printf        ; int printf(const char *format);
|           0x08048418      8d45fc         lea eax, dword [ebp - local_4h]
|           0x0804841b      89442404       mov dword [esp + local_4h_2], eax
|           0x0804841f      c704244c8504.  mov dword [esp], 0x804854c  ; [0x804854c:4]=0x49006425 ; "%d"
|           0x08048426      e8e1feffff     call sym.imp.scanf         ; int scanf(const char *format);
|           0x0804842b      817dfc9a1400.  cmp dword [ebp - local_4h], 0x149a ; [0x149a:4]=0x2ec0804
|       ,=< 0x08048432      740e           je 0x8048442
|       |   0x08048434      c704244f8504.  mov dword [esp], str.Invalid_Password__n ; [0x804854f:4]=0x61766e49 LEA str.Invalid_Password__n ; "Invalid Password!." @ 0x804854f
|       |   0x0804843b      e8dcfeffff     call sym.imp.printf        ; int printf(const char *format);
|      ,==< 0x08048440      eb0c           jmp 0x804844e
|      ||   ; JMP XREF from 0x08048432 (sym.main)
|      |`-> 0x08048442      c70424628504.  mov dword [esp], str.Password_OK_:__n ; [0x8048562:4]=0x73736150 LEA str.Password_OK_:__n ; "Password OK :)." @ 0x8048562
|      |    0x08048449      e8cefeffff     call sym.imp.printf        ; int printf(const char *format);
|      |    ; JMP XREF from 0x08048440 (sym.main)
|      `--> 0x0804844e      b800000000     mov eax, 0
|           0x08048453      c9             leave
\           0x08048454      c3             ret
            0x08048455      90             nop
            0x08048456      90             nop
            0x08048457      90             nop
            0x08048458      90             nop
            0x08048459      90             nop
            0x0804845a      90             nop
            0x0804845b      90             nop
            0x0804845c      90             nop
            0x0804845d      90             nop
            0x0804845e      90             nop
            0x0804845f      90             nop
/ (fcn) sym.__libc_csu_init 99
|   sym.__libc_csu_init (int arg_8h, int arg_ch, int arg_10h);
|           ; var int local_10h @ ebp-0x10
|           ; arg int arg_8h @ ebp+0x8
|           ; arg int arg_ch @ ebp+0xc
|           ; arg int arg_10h @ ebp+0x10
|           ; var int local_4h @ esp+0x4
|           ; var int local_8h @ esp+0x8
|           ; DATA XREF from 0x08048340 (entry0)
|           0x08048460      55             push ebp
|           0x08048461      89e5           mov ebp, esp
|           0x08048463      57             push edi
|           0x08048464      56             push esi
|           0x08048465      31f6           xor esi, esi
|           0x08048467      53             push ebx
|           0x08048468      e868000000     call sym.__i686.get_pc_thunk.bx
|           0x0804846d      81c3871b0000   add ebx, 0x1b87
|           0x08048473      83ec1c         sub esp, 0x1c
|           0x08048476      e859feffff     call sym._init
|           0x0804847b      8d8318ffffff   lea eax, dword [ebx - 0xe8]
|           0x08048481      8d9318ffffff   lea edx, dword [ebx - 0xe8]
|           0x08048487      8945f0         mov dword [ebp - local_10h], eax
|           0x0804848a      29d0           sub eax, edx
|           0x0804848c      c1f802         sar eax, 2
|           0x0804848f      39c6           cmp esi, eax
|       ,=< 0x08048491      7328           jae 0x80484bb
|       |   0x08048493      89d7           mov edi, edx
|       |   ; JMP XREF from 0x080484b9 (sym.__libc_csu_init)
|       |   0x08048495      8b4510         mov eax, dword [ebp + arg_10h] ; [0x10:4]=0x30002
[0x080484e4]>
```

###### Solving crackme0x01

All Calls

```sh
|           0x08048407      e810ffffff     call sym.imp.printf        ; int printf(const char *format);
|           0x08048413      e804ffffff     call sym.imp.printf        ; int printf(const char *format);
|           0x08048426      e8e1feffff     call sym.imp.scanf         ; int scanf(const char *format);
|       |   0x0804843b      e8dcfeffff     call sym.imp.printf        ; int printf(const char *format);
|       |   0x08048449      e8cefeffff     call sym.imp.printf        ; int printf(const char *format);
```

There is no calls to any ```strcmp```

Having a look at the code before ```cmp```

```sh
|           0x08048418      8d45fc         lea eax, dword [ebp - local_4h]
|           0x0804841b      89442404       mov dword [esp + local_4h_2], eax
|           0x0804841f      c704244c8504.  mov dword [esp], 0x804854c  ; [0x804854c:4]=0x49006425 ; "%d"
|           0x08048426      e8e1feffff     call sym.imp.scanf         ; int scanf(const char *format);
|           0x0804842b      817dfc9a1400.  cmp dword [ebp - local_4h], 0x149a ; [0x149a:4]=0x2ec0804
```

1. Program gets the user input from ```scanf``` call at ```0x08048426```

	The first argument is a integer constant which can be deduces using the format specifier ```%d```
	
	The second argument is the memory location to store the scanf() result. The result of scanf() is stored in local stack variable at ```ebp - local_4h```.

2. The ```cmp``` operand is performed on ```ebp - local_4h``` {user provided input} and ```0x149a```

	```sh
	root@kali:~/binexp/challenges# echo $((0x149a))
	5274
	root@kali:~/binexp/challenges#
	```

3. Finally

	```sh
	root@kali:~/binexp/challenges# ./crackme0x01
	IOLI Crackme Level 0x01
	Password: 5274
	Password OK :)
	root@kali:~/binexp/challenges#
	```